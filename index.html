<!--[[[cog
from regexesfear import showregex
from showcode import showcode, runscript
import re
]]]-->
<!--[[[end]]]-->

<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Regular Expressions Are Nothing to Fear</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/simple.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">


<section>
  <h2>Regular Expressions Are Nothing to Fear</h2>
  <br/>
  <h3>Doug Hellmann</h3>
  <h4>PyATL, February 2017</h4>
</section>



<section>
  <h2>What are <br/><em>"Regular Expressions"</em><br/>?</h2>

  <p>Formal Language for Matching Patterns in Text</p>

  <aside class="notes">
    <em>blah blah blah</em>
  </aside>
</section>



<section>
  <h2>Their Uses</h2>

  <ul>
    <li>Finding</li>
    <li>Parsing</li>
    <li>Editing</li>
  </ul>

<aside class="notes">
<ul>
<li>Finding function definitions in a file or lines in a log file.</li>
<li>Parsing data files.</li>
<li>Search and replace using a text editor.</li>
</aside>

</section>



<section>
  <h2>Simple Example Expression</h2>

<!--[[[cog
showregex("Does the pattern match this text?", "t")
]]]-->
<p><tt>t</tt></p>
<pre data-trim>
Does the pattern match this text?
</pre>

<pre data-trim class="fragment fade-in">
Does <mark>t</mark>he pa<mark>t</mark><mark>t</mark>ern ma<mark>t</mark>ch <mark>t</mark>his <mark>t</mark>ex<mark>t</mark>?
</pre>
<!--[[[end]]]-->

<aside class="notes">
The simplest pattern is a single character, such as this T.

It would match 7 times in the input text.
</aside>
</section>



<section>
  <h2>Using <tt>re</tt> from Python</h2>
<!--[[[cog
showcode('ex1.py')
runscript('ex1.py', fade_in=True)
]]]-->
<pre><code data-trim>

import re

s = "Does the pattern match this text?"

pattern = re.compile("t")

print(pattern.search(s))

</code></pre>

<pre data-trim data-noescape class="fragment fade-in">
<_sre.SRE_Match object; span=(5, 6), match='t'>

</pre>

<!--[[[end]]]-->

<aside class="notes">
<p>The search() method looks for a pattern in the input string and
returns a Match object with details about where it is found, or None
if it is not.</p>

<p>We'll talk more about Match objects, but for now I want to focus on
the language syntax.</p>
</aside>
</section>



<section>
<h2>Multi-part Expressions</h2>

<!--[[[cog
showregex("Does the pattern match this text?", "this")
]]]-->
<p><tt>this</tt></p>
<pre data-trim>
Does the pattern match this text?
</pre>

<pre data-trim class="fragment fade-in">
Does the pattern match <mark>this</mark> text?
</pre>
<!--[[[end]]]-->

<aside class="notes">
<p>A single letter is obviously not that useful. The expression syntax
supports multiple parts.</p>

<p>This pattern matches the 4 literal characters in the word "this",
and is processed by matching the T then H then I then S</p>

<p>Each letter is actually a "subexpression", and the usefulness of
that will be clear as the patterns get more complicated.</p>
</aside>
</section>



<section>
<h2>Repetition</h2>

<!--[[[cog
showregex("Does the pattern match this text?", "tt")
]]]-->
<p><tt>tt</tt></p>
<pre data-trim>
Does the pattern match this text?
</pre>

<pre data-trim class="fragment fade-in">
Does the pa<mark>tt</mark>ern match this text?
</pre>
<!--[[[end]]]-->

<aside class="notes">
<p>Sometimes it's useful to look for the same expression appearing
multiple times in a row.</p>

<p>One way to do that is to repeat the expression in the pattern. The
expression language supports repetition rules directly, though.</p>
</aside>
</section>



<section>
<h2>Repetition</h2>

<!--[[[cog
showregex("Does the pattern match this text?", "t{2}")
]]]-->
<p><tt>t{2}</tt></p>
<pre data-trim>
Does the pattern match this text?
</pre>

<pre data-trim class="fragment fade-in">
Does the pa<mark>tt</mark>ern match this text?
</pre>
<!--[[[end]]]-->

<aside class="notes">
<p>This expression means match the letter T appearing twice.</p>

<p>It's obviously more of a shortcut for more recurrences than 2.</p>
</aside>
</section>



<section>
<h2>Repetition</h2>

<!--[[[cog
showregex("Does the pattern match this text?", "t{2,3}")
]]]-->
<p><tt>t{2,3}</tt></p>
<pre data-trim>
Does the pattern match this text?
</pre>

<pre data-trim class="fragment fade-in">
Does the pa<mark>tt</mark>ern match this text?
</pre>
<!--[[[end]]]-->

<aside class="notes">
<p>This syntax means match T appearing between 2 and 3 times.</p>
</aside>
</section>



<section>
<h2>Repetition</h2>

<!--[[[cog
showregex("Does the pattern match this text?", "t+")
]]]-->
<p><tt>t+</tt></p>
<pre data-trim>
Does the pattern match this text?
</pre>

<pre data-trim class="fragment fade-in">
Does <mark>t</mark>he pa<mark>tt</mark>ern ma<mark>t</mark>ch <mark>t</mark>his <mark>t</mark>ex<mark>t</mark>?
</pre>
<!--[[[end]]]-->

<aside class="notes">
<p>This syntax means match T at least one time.</p>

<p>The results look similar to the first expression, except that the
pair of Ts in "pattern" are matched as one instance.</p>
</aside>
</section>


<section>
<h2>Wildcards</h2>

<!--[[[cog
showregex("Does the pattern match this text?", "t..t")
]]]-->
<p><tt>t..t</tt></p>
<pre data-trim>
Does the pattern match this text?
</pre>

<pre data-trim class="fragment fade-in">
Does the pattern match this <mark>text</mark>?
</pre>
<!--[[[end]]]-->

<aside class="notes">
<p>Sometime's it's useful to match part of the text without being
explicit about it. The dot matches any character.</p>

<p>This example looks for 4 characters a T followed by any 2
characters followed by another T.</p>
</aside>
</section>



<section>
<h2>Wildcards</h2>

<!--[[[cog
showregex("Does the pattern match this text?", "t.+t")
]]]-->
<p><tt>t.+t</tt></p>
<pre data-trim>
Does the pattern match this text?
</pre>

<pre data-trim class="fragment fade-in">
Does <mark>the pattern match this text</mark>?
</pre>
<!--[[[end]]]-->

<aside class="notes">
<p>Dots can be combined with wildcards, too, but be careful!</p>

<p>Repetition using + is "greedy" by default, and when that's combined
with the dot wildcard it can result in matching more than
expected.</p>
</aside>
</section>



<section>
<h2>Non-greedy Repetition</h2>

<!--[[[cog
showregex("Does the pattern match this text?", "t.+?t")
]]]-->
<p><tt>t.+?t</tt></p>
<pre data-trim>
Does the pattern match this text?
</pre>

<pre data-trim class="fragment fade-in">
Does <mark>the pat</mark><mark>tern mat</mark>ch <mark>this t</mark>ext?
</pre>
<!--[[[end]]]-->

<aside class="notes">
<p>Dots can be combined with wildcards, too, but be careful!</p>

<p>Repetition using + is "greedy" by default, and when that's combined
with the dot wildcard it can result in matching more than
expected.</p>
</aside>
</section>



<section>
<h2>Repetition</h2>

<!--[[[cog
showregex("Does the pattern match this text?", "t.*t")
]]]-->
<p><tt>t.*t</tt></p>
<pre data-trim>
Does the pattern match this text?
</pre>

<pre data-trim class="fragment fade-in">
Does <mark>the pattern match this text</mark>?
</pre>
<!--[[[end]]]-->

<aside class="notes">
<p>A * instead of + means "0 or more"</p>
<p>Again, the greedy operator has consumed the entire input text.</p>
</aside>
</section>



<section>
<h2>Non-greedy Repetition</h2>

<!--[[[cog
showregex("Does the pattern match this text?", "t.*?t")
]]]-->
<p><tt>t.*?t</tt></p>
<pre data-trim>
Does the pattern match this text?
</pre>

<pre data-trim class="fragment fade-in">
Does <mark>the pat</mark><mark>tern mat</mark>ch <mark>this t</mark>ext?
</pre>
<!--[[[end]]]-->

<aside class="notes">
<p>Adding a question mark gives us 3 matches again</p>
</aside>
</section>



<section>
<h2>Character Sets</h2>

<!--[[[cog
showregex("Does the pattern match this text?", "t[aeiou]")
]]]-->
<p><tt>t[aeiou]</tt></p>
<pre data-trim>
Does the pattern match this text?
</pre>

<pre data-trim class="fragment fade-in">
Does the pat<mark>te</mark>rn match this <mark>te</mark>xt?
</pre>
<!--[[[end]]]-->

<aside class="notes">
<p>The square brackets indicate a set of characters, any one of which
can match.</p>
</aside>
</section>



<section>
<h2>Exclusive Character Sets</h2>

<!--[[[cog
showregex("Does the pattern match this text?", "t[^aeiou]")
]]]-->
<p><tt>t[^aeiou]</tt></p>
<pre data-trim>
Does the pattern match this text?
</pre>

<pre data-trim class="fragment fade-in">
Does <mark>th</mark>e pa<mark>tt</mark>ern ma<mark>tc</mark>h <mark>th</mark>is tex<mark>t?</mark>
</pre>
<!--[[[end]]]-->

<aside class="notes">
<p>If the first entry in the character set is ^ (caret), then the set
is negated and the match must not be a member.</p>
</aside>
</section>



<section>
<h2>Character Ranges</h2>

<!--[[[cog
showregex("Does the pattern match this text?", "t[a-zA-Z]")
]]]-->
<p><tt>t[a-zA-Z]</tt></p>
<pre data-trim>
Does the pattern match this text?
</pre>

<pre data-trim class="fragment fade-in">
Does <mark>th</mark>e pa<mark>tt</mark>ern ma<mark>tc</mark>h <mark>th</mark>is <mark>te</mark>xt?
</pre>
<!--[[[end]]]-->

<aside class="notes">
<p>The character set can express a range using a dash between entries</p>
</aside>
</section>



<section>
<h2>Character Classes: Digits</h2>

<!--[[[cog
showregex("Athens, 30605", r"\d{5}")
]]]-->
<p><tt>\d{5}</tt></p>
<pre data-trim>
Athens, 30605
</pre>

<pre data-trim class="fragment fade-in">
Athens, <mark>30605</mark>
</pre>
<!--[[[end]]]-->

<aside class="notes">
<p>Several pre-defined character classes are available for use. They
are expressed using a backslash to escape a character mneumonic. In
this case, \d means a digit.</p>
</aside>
</section>



<section>
<h2>Character Classes: Digits</h2>

<!--[[[cog
showregex("Athens, 30605", r"\D+")
]]]-->
<p><tt>\D+</tt></p>
<pre data-trim>
Athens, 30605
</pre>

<pre data-trim class="fragment fade-in">
<mark>Athens, </mark>30605
</pre>
<!--[[[end]]]-->

<aside class="notes">
<p>The lower and upper case versions of an escape sequence are usually
opposites. So backslash uppercase D means "not a digit".</p>
</aside>
</section>



<section>
<h2>Character Classes: Whitespace</h2>

<!--[[[cog
showregex("Athens, 30605", r"\s+")
]]]-->
<p><tt>\s+</tt></p>
<pre data-trim>
Athens, 30605
</pre>

<pre data-trim class="fragment fade-in">
Athens,<mark> </mark>30605
</pre>
<!--[[[end]]]-->

<aside class="notes">
<p>The whitespace class matches tabs, spaces, and newlines.</p>
</aside>
</section>



<section>
<h2>Character Classes: Whitespace</h2>

<!--[[[cog
showregex("Athens, 30605", r"\S+")
]]]-->
<p><tt>\S+</tt></p>
<pre data-trim>
Athens, 30605
</pre>

<pre data-trim class="fragment fade-in">
<mark>Athens,</mark> <mark>30605</mark>
</pre>
<!--[[[end]]]-->

<aside class="notes">
</aside>
</section>



<section>
<h2>Character Classes: Alphanumeric</h2>

<!--[[[cog
showregex("Athens, 30605", r"\w+")
]]]-->
<p><tt>\w+</tt></p>
<pre data-trim>
Athens, 30605
</pre>

<pre data-trim class="fragment fade-in">
<mark>Athens</mark>, <mark>30605</mark>
</pre>
<!--[[[end]]]-->

<aside class="notes">
<p>All of the pre-defined character classes are unicode and
locale-aware, which is especially useful for alphanumeric.<p>
<p>Note here that the comma and space are excluded.<p>
</aside>
</section>



<section>
<h2>Character Classes: Alphanumeric</h2>

<!--[[[cog
showregex("Athens, 30605", r"\W+")
]]]-->
<p><tt>\W+</tt></p>
<pre data-trim>
Athens, 30605
</pre>

<pre data-trim class="fragment fade-in">
Athens<mark>, </mark>30605
</pre>
<!--[[[end]]]-->

<aside class="notes">
</aside>
</section>



<section>
<h2>Anchoring</h2>

<!--[[[cog
showregex("Does the pattern match this text?", "^t")
]]]-->
<p><tt>^t</tt></p>
<pre data-trim>
Does the pattern match this text?
</pre>

<pre data-trim class="fragment fade-in">
(no match)
</pre>
<!--[[[end]]]-->

<aside class="notes">
<p>Within a pattern, caret means to anchor the search to the start of
the string. The remainder of the expression will only match if it
appears at the start of the string or line.</p>
</aside>
</section>



<section>
<h2>Anchoring</h2>

<!--[[[cog
showregex("Does the pattern match this text?", r"\?$")
]]]-->
<p><tt>\?$</tt></p>
<pre data-trim>
Does the pattern match this text?
</pre>

<pre data-trim class="fragment fade-in">
Does the pattern match this text<mark>?</mark>
</pre>
<!--[[[end]]]-->

<aside class="notes">
<p>A dollar sign means anchor to the end of the string.</p>
</aside>
</section>



<section>
<h2>Anchoring</h2>

<!--[[[cog
showregex("Does the pattern match this text?", r"\bt")
]]]-->
<p><tt>\bt</tt></p>
<pre data-trim>
Does the pattern match this text?
</pre>

<pre data-trim class="fragment fade-in">
Does <mark>t</mark>he pattern match <mark>t</mark>his <mark>t</mark>ext?
</pre>
<!--[[[end]]]-->

<aside class="notes">
<p>The lowercase b matches the beginning of a word.</p>
</aside>
</section>



<section>
<h2>Anchoring</h2>

<!--[[[cog
showregex("Does the pattern match this text?", r"\Bt")
]]]-->
<p><tt>\Bt</tt></p>
<pre data-trim>
Does the pattern match this text?
</pre>

<pre data-trim class="fragment fade-in">
Does the pa<mark>t</mark><mark>t</mark>ern ma<mark>t</mark>ch this tex<mark>t</mark>?
</pre>
<!--[[[end]]]-->

<aside class="notes">
<p>The uppercase B matches anywhere other than the beginning of a word.</p>
</aside>
</section>



<section>
<h2>Grouping</h2>

<!--[[[cog
showregex("Does the pattern match this text?", r"\bt(\w+)t\W")
]]]-->
<p><tt>\bt(\w+)t\W</tt></p>
<pre data-trim>
Does the pattern match this text?
</pre>

<pre data-trim class="fragment fade-in">
Does the pattern match this <mark>text?</mark>

(1, 1) ex
</pre>
<!--[[[end]]]-->

<aside class="notes">
<p>Parentheses define groups or sub-patterns. This expression looks
for the characters between Ts at the start and end of a word.</p>

<p>The entire pattern matches "text?" at the end of the string, but
the group only contains "ex".</p>
</aside>
</section>



<section>
<h2>Grouping</h2>

<!--[[[cog
showregex("Does the pattern match this text?", r"\b(t\w{2}|t..t)\W")
]]]-->
<p><tt>\b(t\w{2}|t..t)\W</tt></p>
<pre data-trim>
Does the pattern match this text?
</pre>

<pre data-trim class="fragment fade-in">
Does <mark>the </mark>pattern match this <mark>text?</mark>

(1, 1) the

(2, 1) text
</pre>
<!--[[[end]]]-->

<aside class="notes">
<p>A vertical bar within a group defines an alternate pattern. This
pattern looks for three letter words starting with T or four letter
words starting and ending with T.</p>
</aside>
</section>



<section>
<h2>Parsing With Groups</h2>

<!--[[[cog
log_line = r'80.5.216.116 - - [14/Jan/2017:12:20:35 -0800] "GET /3/re/index.html HTTP/1.1" 200 180340 "https://pymotw.com/3/index.html" "Mozilla/5.0 (X11; Linux x86_64; rv:50.0) Gecko/20100101 Firefox/50.0"'
ip_address = r'((\d{1,3}\.){3}\d{1,3})'
date = r'\[([^]]+)\]'
request = r'"((\w+) ([^"]*) HTTP/[^"]+)"'
response = r'(\d+)'
all_parts = '^' + ip_address + r'.*' + date + '[^"]*' + request + r'\s+' + response
showregex(log_line, ip_address)
]]]-->
<p><tt>((\d{1,3}\.){3}\d{1,3})</tt></p>
<pre data-trim>
80.5.216.116 - - [14/Jan/2017:12:20:35 -0800] "GET /3/re/index.html HTTP/1.1" 200 180340 "https://pymotw.com/3/index.html" "Mozilla/5.0 (X11; Linux x86_64; rv:50.0) Gecko/20100101 Firefox/50.0"
</pre>

<pre data-trim class="fragment fade-in">
<mark>80.5.216.116</mark> - - [14/Jan/2017:12:20:35 -0800] "GET /3/re/index.html HTTP/1.1" 200 180340 "https://pymotw.com/3/index.html" "Mozilla/5.0 (X11; Linux x86_64; rv:50.0) Gecko/20100101 Firefox/50.0"

(1, 1) 80.5.216.116
(1, 2) 216.
</pre>
<!--[[[end]]]-->

<aside class="notes">
<p></p>
</aside>
</section>



<section>
<h2>Parsing With Groups</h2>

<!--[[[cog
showregex(log_line, date)
]]]-->
<p><tt>\[([^]]+)\]</tt></p>
<pre data-trim>
80.5.216.116 - - [14/Jan/2017:12:20:35 -0800] "GET /3/re/index.html HTTP/1.1" 200 180340 "https://pymotw.com/3/index.html" "Mozilla/5.0 (X11; Linux x86_64; rv:50.0) Gecko/20100101 Firefox/50.0"
</pre>

<pre data-trim class="fragment fade-in">
80.5.216.116 - - <mark>[14/Jan/2017:12:20:35 -0800]</mark> "GET /3/re/index.html HTTP/1.1" 200 180340 "https://pymotw.com/3/index.html" "Mozilla/5.0 (X11; Linux x86_64; rv:50.0) Gecko/20100101 Firefox/50.0"

(1, 1) 14/Jan/2017:12:20:35 -0800
</pre>
<!--[[[end]]]-->

<aside class="notes">
<p></p>
</aside>
</section>



<section>
<h2>Parsing With Groups</h2>

<!--[[[cog
showregex(log_line, request)
]]]-->
<p><tt>"((\w+) ([^"]*) HTTP/[^"]+)"</tt></p>
<pre data-trim>
80.5.216.116 - - [14/Jan/2017:12:20:35 -0800] "GET /3/re/index.html HTTP/1.1" 200 180340 "https://pymotw.com/3/index.html" "Mozilla/5.0 (X11; Linux x86_64; rv:50.0) Gecko/20100101 Firefox/50.0"
</pre>

<pre data-trim class="fragment fade-in">
80.5.216.116 - - [14/Jan/2017:12:20:35 -0800] <mark>"GET /3/re/index.html HTTP/1.1"</mark> 200 180340 "https://pymotw.com/3/index.html" "Mozilla/5.0 (X11; Linux x86_64; rv:50.0) Gecko/20100101 Firefox/50.0"

(1, 1) GET /3/re/index.html HTTP/1.1
(1, 2) GET
(1, 3) /3/re/index.html
</pre>
<!--[[[end]]]-->

<aside class="notes">
<p></p>
</aside>
</section>



<section>
<h2>Parsing With Groups</h2>

<!--[[[cog
showregex(log_line, all_parts)
]]]-->
<p><tt>^((\d{1,3}\.){3}\d{1,3}).*\[([^]]+)\][^"]*"((\w+) ([^"]*) HTTP/[^"]+)"\s+(\d+)</tt></p>
<pre data-trim>
80.5.216.116 - - [14/Jan/2017:12:20:35 -0800] "GET /3/re/index.html HTTP/1.1" 200 180340 "https://pymotw.com/3/index.html" "Mozilla/5.0 (X11; Linux x86_64; rv:50.0) Gecko/20100101 Firefox/50.0"
</pre>

<pre data-trim class="fragment fade-in">
<mark>80.5.216.116 - - [14/Jan/2017:12:20:35 -0800] "GET /3/re/index.html HTTP/1.1" 200</mark> 180340 "https://pymotw.com/3/index.html" "Mozilla/5.0 (X11; Linux x86_64; rv:50.0) Gecko/20100101 Firefox/50.0"

(1, 1) 80.5.216.116
(1, 2) 216.
(1, 3) 14/Jan/2017:12:20:35 -0800
(1, 4) GET /3/re/index.html HTTP/1.1
(1, 5) GET
(1, 6) /3/re/index.html
(1, 7) 200
</pre>
<!--[[[end]]]-->

<aside class="notes">
<p></p>
</aside>
</section>



<section>
<h2>re.VERBOSE</h2>

<!--[[[cog
verbose = r'''^
{ip_address}  # <mark>IP Address</mark>
.*
{date}  # <mark>Date</mark>
[^"]*
{request}  # <mark>Request</mark>
\s+
{response}  # <mark>Response code</mark>'''.format(**(locals()))
showregex(log_line, verbose, re.VERBOSE)
]]]-->
<pre data-trim>
^
((\d{1,3}\.){3}\d{1,3})  # <mark>IP Address</mark>
.*
\[([^]]+)\]  # <mark>Date</mark>
[^"]*
"((\w+) ([^"]*) HTTP/[^"]+)"  # <mark>Request</mark>
\s+
(\d+)  # <mark>Response code</mark>
</pre>
<pre data-trim>
80.5.216.116 - - [14/Jan/2017:12:20:35 -0800] "GET /3/re/index.html HTTP/1.1" 200 180340 "https://pymotw.com/3/index.html" "Mozilla/5.0 (X11; Linux x86_64; rv:50.0) Gecko/20100101 Firefox/50.0"
</pre>

<pre data-trim class="fragment fade-in">
<mark>80.5.216.116 - - [14/Jan/2017:12:20:35 -0800] "GET /3/re/index.html HTTP/1.1" 200</mark> 180340 "https://pymotw.com/3/index.html" "Mozilla/5.0 (X11; Linux x86_64; rv:50.0) Gecko/20100101 Firefox/50.0"

(1, 1) 80.5.216.116
(1, 2) 216.
(1, 3) 14/Jan/2017:12:20:35 -0800
(1, 4) GET /3/re/index.html HTTP/1.1
(1, 5) GET
(1, 6)  /3/re/index.html 
(1, 7) 200
</pre>
<!--[[[end]]]-->

<aside class="notes">
<p></p>
</aside>
</section>


<section>
<small>
  <a href="https://github.com/dhellmann/presentation-regexes-fear">http://github.com/dhellmann/presentation-regexes-fear</a><br/>
  <a href="https://pymotw.com/3/re/">https://pymotw.com/3/re</a>
  <br/>
  <br/>
  <a href="http://amzn.to/2jjtXgc"><i>Mastering Regular Expressions</i> by Jeffrey Freidl</a>
</small>
</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				history: true,

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js',
                      async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
